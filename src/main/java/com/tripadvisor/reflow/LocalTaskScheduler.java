package com.tripadvisor.reflow;

import java.util.ArrayList;
import java.util.Collection;
import java.util.concurrent.ConcurrentHashMap;
import java.util.concurrent.ConcurrentMap;
import java.util.concurrent.ExecutionException;
import java.util.concurrent.Executor;
import java.util.concurrent.FutureTask;
import java.util.function.Function;

import com.google.common.base.Preconditions;

/**
 * A task scheduler that executes tasks locally via an {@link Executor}.
 *
 * <p>Scheduling tokens generated by this class can only be used with the
 * instance that generated them, but they remain valid indefinitely.</p>
 */
public class LocalTaskScheduler<T> implements TaskScheduler<T>
{
    private final Executor m_executor;
    private final Function<T, ? extends Runnable> m_taskToRunnableFunc;
    private final ConcurrentMap<ScheduledTaskToken, CallReturningFuture> m_futures = new ConcurrentHashMap<>();

    private LocalTaskScheduler(Executor executor, Function<T, ? extends Runnable> taskToRunnableFunc)
    {
        m_executor = executor;
        m_taskToRunnableFunc = taskToRunnableFunc;
    }

    /**
     * Returns a task scheduler, backed by the given executor,
     * for tasks that implement the {@link Runnable} interface.
     */
    public static LocalTaskScheduler<Runnable> create(Executor executor)
    {
        return new LocalTaskScheduler<>(Preconditions.checkNotNull(executor), Function.identity());
    }

    /**
     * Returns a task scheduler, backed by the given executor, that uses the
     * given function to translate tasks into {@link Runnable} instances.
     */
    public static <U> LocalTaskScheduler<U> create(Executor executor,
                                                   Function<U, ? extends Runnable> taskToRunnableFunc)
    {
        return new LocalTaskScheduler<>(Preconditions.checkNotNull(executor),
                                        Preconditions.checkNotNull(taskToRunnableFunc));
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public ScheduledTaskToken submit(T task, TaskCompletionCallback callback)
    {
        CallReturningFuture future = new CallReturningFuture(m_taskToRunnableFunc.apply(task));
        future.addCallback(callback);

        ScheduledTaskToken token = new ScheduledTaskToken() {};
        m_futures.put(token, future);
        m_executor.execute(future);

        return token;
    }

    /**
     * {@inheritDoc}
     */
    @Override
    public void registerCallback(ScheduledTaskToken token, TaskCompletionCallback callback) throws InvalidTokenException
    {
        CallReturningFuture future = m_futures.get(token);
        if (future == null)
        {
            throw new InvalidTokenException();
        }
        future.addCallback(callback);
    }

    private static class CallReturningFuture extends FutureTask<Void>
    {
        private Collection<TaskCompletionCallback> m_callbacks = new ArrayList<>(1);

        public CallReturningFuture(Runnable runnable)
        {
            super(runnable, null);
        }

        public synchronized void addCallback(TaskCompletionCallback callback)
        {
            Preconditions.checkNotNull(callback);

            if (isDone())
            {
                try
                {
                    get();
                    callback.reportSuccess();
                }
                catch (ExecutionException e)
                {
                    // Unfortunately, to access the actual failure cause, we have to wrap it
                    // via a call to get(), catch the wrapper, and unwrap it here
                    callback.reportFailure(e.getCause());
                }
                catch (InterruptedException e)
                {
                    // Because isDone() returned true, this future must be completed or be in the process
                    // of being completed. The latter can only be true while the superclass methods set()
                    // and setException() are executing, which can't coincide with a call to this method
                    // due to synchronization. Therefore, this future must be completed and the call to
                    // get() should immediately return.
                    throw new AssertionError("Unexpected interrupt", e);
                }
            }
            else
            {
                m_callbacks.add(callback);
            }
        }

        @Override
        protected synchronized void set(Void v)
        {
            super.set(v);
            for (TaskCompletionCallback callback : m_callbacks)
            {
                callback.reportSuccess();
            }
            m_callbacks = null;
        }

        @Override
        protected synchronized void setException(Throwable t)
        {
            super.setException(t);
            for (TaskCompletionCallback callback : m_callbacks)
            {
                callback.reportFailure(t);
            }
            m_callbacks = null;
        }
    }
}
